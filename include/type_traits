// Type traits and metaprogramming utilities -*- C++ -*-

// Copyright (C) 1997-2017 Free Software Foundation, Inc.
//
// This file is part of the Polaris C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file type_traits
 *  This is a Polaris C++ Library header.
 */

// Written by Jingyu Zhao.

#ifndef _POLLIB_TYPE_TRAITS
#define _POLLIB_TYPE_TRAITS 1

#pragma GCC system_header

#include <polaris/version>
#include <polaris/bits/type.h>
#include <polaris/bits/type.tcc>
#include <type_traits>

namespace polaris
{

inline namespace type_traits
{

// template_placeholder
typedef void template_placeholder;

#if _POL_NEWLIB

template<typename _Cond, typename _Tp = void>
struct require
{
	typedef typename std::enable_if<_Cond::value, _Tp>::type type;
};

template<typename _Cond, typename _Tp = void>
using require_t = typename require<_Cond, _Tp>::type;

template<bool _Cond, typename _Tp = void>
struct brequire
{
	typedef typename std::enable_if<_Cond, _Tp>::type type;
};

template<bool _Cond, typename _Tp = void>
using brequire_t = typename brequire<_Cond, _Tp>::type;

#else

// requirement
template<typename _Cond, typename _Tp = void>
struct requirement
{
	typedef typename std::enable_if<_Cond::value, _Tp>::type type;
};

// require
template<typename _Cond, typename _Tp = void>
using require = typename requirement<_Cond, _Tp>::type;

// require_bool
template<bool _Cond, typename _Tp = void>
using require_bool = typename std::enable_if<_Cond, _Tp>::type;

#endif

// invoke_result
template<typename _Sig>
using invoke_result = std::result_of<_Sig>;

// true_type, false_type
typedef std::true_type true_type;
typedef std::false_type false_type;

// success_type
template<typename _Tp>
struct success_type
{
	typedef _Tp type;
};

// failure_type
struct failure_type
{
};

// bool_constant
template<bool _Val>
struct bool_constant
	: public std::integral_constant<bool, _Val>
{
};

// conjunction
template<typename...>
struct conjunction;

template<>
struct conjunction<>
	: public true_type
{
};

template<typename _Tp>
struct conjunction<_Tp>
	: public _Tp
{
};

template<typename _Tp, typename _Up>
struct conjunction<_Tp, _Up>
	: public std::conditional<_Tp::value, _Up, _Tp>::type
{
};

template<typename _Tp, typename _Up, typename _Vp, typename... _Args>
struct conjunction<_Tp, _Up, _Vp, _Args...>
	: public std::conditional<_Tp::value, conjunction<_Up, _Vp, _Args...>,
		_Tp>::type
{
};

// disjunction
template<typename...>
struct disjunction;

template<>
struct disjunction<>
	: public false_type
{
};

template<typename _Tp>
struct disjunction<_Tp>
	: public _Tp
{
};

template<typename _Tp, typename _Up>
struct disjunction<_Tp, _Up>
	: public std::conditional<_Tp::value, _Tp, _Up>::type
{
};

template<typename _Tp, typename _Up, typename _Vp, typename... _Args>
struct disjunction<_Tp, _Up, _Vp, _Args...>
	: public std::conditional<_Tp::value, _Tp, disjunction<_Up, _Vp,
		_Args...>>::type
{
};

// negation
template<typename _Tp>
struct negation
	: public bool_constant<!_Tp::value>
{
};

// __do_is_callable_impl
struct __do_is_callable_impl
{
	template<typename _Tp, typename = decltype(std::declval<_Tp&>()())>
	static true_type __test(int);

	template<typename>
	static false_type __test(...);
};

// __is_callable_impl
template<typename _Tp>
struct __is_callable_impl
	: public __do_is_callable_impl
{
	typedef decltype(__test<_Tp>(0)) type;
};

// is_callable
template<typename _Tp>
struct is_callable
	: public __is_callable_impl<_Tp>::type
{
};

// is_functor
template<typename _Tp>
struct is_functor
	: public bool_constant<conjunction<is_callable<_Tp>,
		negation<std::is_function<_Tp>>>::value>
{
};

// __do_is_eq_comp_with_impl
struct __do_is_eq_comp_with_impl
{
	template<typename _Tp, typename _Up, typename = decltype(
		std::declval<_Tp&>() == std::declval<_Up&>())>
	static true_type __test(int);

	template<typename, typename>
	static false_type __test(...);
};

// __is_eq_comp_with_impl
template<typename _Tp, typename _Up>
struct __is_eq_comp_with_impl
	: public __do_is_eq_comp_with_impl
{
	typedef decltype(__test<_Tp, _Up>(0)) type;
};

// is_equality_comparable_with
template<typename _Tp, typename _Up>
struct is_equality_comparable_with
	: public __is_eq_comp_with_impl<_Tp, _Up>::type
{
};

// __is_eq_comp_impl
template<typename _Tp>
struct __is_eq_comp_impl
	: public __do_is_eq_comp_with_impl
{
	typedef decltype(__test<_Tp, _Tp>(0)) type;
};

// is_equality_comparable
template<typename _Tp>
struct is_equality_comparable
	: public __is_eq_comp_impl<_Tp>::type
{
};

// __do_is_lt_comp_with_impl
struct __do_is_lt_comp_with_impl
{
	template<typename _Tp, typename _Up, typename = decltype(
		std::declval<_Tp&>() < std::declval<_Up&>())>
	static true_type __test(int);

	template<typename, typename>
	static false_type __test(...);
};

// __is_lt_comp_with_impl
template<typename _Tp, typename _Up>
struct __is_lt_comp_with_impl
	: public __do_is_lt_comp_with_impl
{
	typedef decltype(__test<_Tp, _Up>(0)) type;
};

// is_less_than_comparable_with
template<typename _Tp, typename _Up>
struct is_less_than_comparable_with
	: public __is_lt_comp_with_impl<_Tp, _Up>::type
{
};

// __is_lt_comp_impl
template<typename _Tp>
struct __is_lt_comp_impl
	: public __do_is_lt_comp_with_impl
{
	typedef decltype(__test<_Tp, _Tp>(0)) type;
};

// is_less_than_comparable
template<typename _Tp>
struct is_less_than_comparable
	: public __is_lt_comp_impl<_Tp>::type
{
};

// __do_is_swappable_with_impl
struct __do_is_swappable_with_impl
{
	template<typename _Tp, typename _Up, typename =
		decltype(std::swap(std::declval<_Tp>(), std::declval<_Up>()))>
	static true_type __test(int);

	template<typename, typename>
	static false_type __test(...);
};

// __is_swappable_with_impl
template<typename _Tp, typename _Up>
struct __is_swappable_with_impl
	: public __do_is_swappable_with_impl
{
	typedef decltype(__test<_Tp, _Up>(0)) type;
};

// is_swappable_with
template<typename _Tp, typename _Up>
struct is_swappable_with
	: public __is_swappable_with_impl<_Tp, _Up>::type
{
};

// TODO...
/** @namespace  polaris::type_traits::concepts
 *  @brief      Polaris type traits concepts support
 *  @note       You should not use it.
**/
inline namespace concepts
{

// c_is_same
template<typename _Tp, typename _Up>
struct c_is_same
	: public std::is_same<_Tp, _Up>
{
};

// c_is_derived_from
template<typename _Tp, typename _Up>
struct c_is_derived_from
	: public conjunction<std::is_base_of<_Up, _Tp>,
		std::is_convertible<std::remove_cv_t<_Tp>*,
		std::remove_cv_t<_Up>*>>
{
};

// __c_is_convertible_to_impl
struct __c_is_convertible_to_impl
{
	template<typename _From, typename _To, typename =
		decltype(static_cast<_To>(std::declval<_From>())),
		typename = require<std::is_convertible<_From, _To>>>
	static true_type __test(int);

	template<typename, typename>
	static false_type __test(...);
};

// c_is_convertible_to
template<typename _From, typename _To>
struct c_is_convertible_to
	: public decltype(__c_is_convertible_to_impl::__test<_From, _To>(0))
{
};

// c_is_integral
template<typename _Tp>
struct c_is_integral
	: public std::is_integral<_Tp>
{
};

// c_is_signed_integral
template<typename _Tp>
struct c_is_signed_integral
	: public conjunction<c_is_integral<_Tp>, std::is_signed<_Tp>>
{
};

// c_is_unsigned_integral
template<typename _Tp>
struct c_is_unsigned_integral
	: public conjunction<c_is_integral<_Tp>, negation<
			c_is_signed_integral<_Tp>>>
{
};

// __c_is_swappable_impl
struct __c_is_swappable_impl
{
	template<typename _Tp, typename = decltype(std::swap(std::declval<_Tp&>(),
		std::declval<_Tp&>()))>
	static true_type __test(int);

	template<typename>
	static false_type __test(...);
};

// c_is_swappable
template<typename _Tp>
struct c_is_swappable
	: public decltype(__c_is_swappable_impl::__test<_Tp>(0))
{
};
/*
template<typename _Tp, typename _Up>
struct c_is_common_reference
	: public conjunction<c_is_same<common_reference_t<_Tp, _Up>,
		common_reference_t<_Up, _Tp>>,
		c_is_convertible_to<_Tp, common_reference_t<_Tp, _Up>>,
		c_is_convertible_to<_Up, common_reference_t<_Tp, _Up>>>
{
};
*/
// c_is_destructible
template<typename _Tp>
struct c_is_destructible
	: public std::is_nothrow_destructible<_Tp>
{
};

// c_is_constructible
template<typename _Tp, typename... _Args>
struct c_is_constructible
	: public conjunction<c_is_destructible<_Tp>,
		std::is_constructible<_Tp, _Args...>>
{
};

// c_is_default_constructible
template<typename _Tp>
struct c_is_default_constructible
	: public c_is_constructible<_Tp>
{
};

// c_is_move_constructible
template<typename _Tp>
struct c_is_move_constructible
	: public conjunction<c_is_constructible<_Tp, _Tp>,
		c_is_convertible_to<_Tp, _Tp>>
{
};

// c_is_copy_constructible
template<typename _Tp>
struct c_is_copy_constructible
	: public conjunction<c_is_move_constructible<_Tp>,
		c_is_constructible<_Tp, _Tp&>,
		c_is_convertible_to<_Tp, _Tp&>,
		c_is_constructible<_Tp, const _Tp&>,
		c_is_convertible_to<const _Tp&, _Tp>,
		c_is_constructible<_Tp, const _Tp>,
		c_is_convertible_to<const _Tp, _Tp>>
{
};

}

inline namespace has_op
{

#define POL_MAKE_HO_CALL(NAME) \
	template<typename _Tp> \
	struct ho_##NAME \
		: public decltype(__ho_##NAME##_impl::__test<_Tp>(0)) \
	{ \
	};

#define POL_MAKE_HO_IMPL1(OP, NAME) \
	struct __ho_##NAME##_impl \
	{ \
		template<typename _Tp, typename = \
			decltype(OP std::declval<_Tp>())> \
		static true_type __test(int); \
		\
		template<typename> \
		static false_type __test(...); \
	};

#define POL_MAKE_HO1(OP, NAME) \
	POL_MAKE_HO_IMPL1(OP, NAME) \
	POL_MAKE_HO_CALL(NAME)

POL_MAKE_HO1(!, logical_not)
POL_MAKE_HO1(~, bitwise_not)
POL_MAKE_HO1(+, positive)
POL_MAKE_HO1(-, negative)
POL_MAKE_HO1(&, address)
POL_MAKE_HO1(*, dereference)

#undef POL_MAKE_HO1
#undef POL_MAKE_HO_IMPL1

#define POL_MAKE_HO_IMPL2(OP, NAME) \
	struct __ho_##NAME##_impl \
	{ \
		template<typename _Tp, typename = \
			decltype(std::declval<_Tp>() OP std::declval<_Tp>())> \
		static true_type __test(int); \
		\
		template<typename> \
		static false_type __test(...); \
	};

#define POL_MAKE_HO2(OP, NAME) \
	POL_MAKE_HO_IMPL2(OP, NAME) \
	POL_MAKE_HO_CALL(NAME)

POL_MAKE_HO2(+, plus)
POL_MAKE_HO2(-, minus)
POL_MAKE_HO2(*, multiplies)
POL_MAKE_HO2(/, divides)
POL_MAKE_HO2(%, modulus)
POL_MAKE_HO2(=, assign)

#undef POL_MAKE_HO2
#undef POL_MAKE_HO_IMPL2
#undef POL_MAKE_HO_CALL

}

}

/* Deprecated & Removed
namespace __tt
{
	using namespace type_traits;
}

namespace __ttc
{
	using namespace type_traits::concepts;
}
*/

}

#endif /* _POLLIB_TYPE_TRAITS */
