#ifndef _POLLIB_MATH
#define _POLLIB_MATH 1

#include <polaris/version>
#include <vector>
#include <string>
#include <sstream>

namespace polaris
{

template<typename _Tp>
bool is_prime(_Tp __x)
{
    if (__x < 2) return false;

    for (_Tp __i = 2; __i * __i <= __x; ++__i)
        if (__x % __i == 0) return false;

    return true;
}

template<typename _Tp>
_Tp min_factor(_Tp __x)
{
    if (__x == 0) return 0;
    if (__x < 2) return 1;

    for (_Tp __i = 2; __i * __i <= __x; ++__i)
        if (__x % __i == 0) return __i;

    return 1;
}

template<typename _Tp>
std::vector<std::pair<_Tp, std::size_t>> prime_factor(_Tp __x)
{
    std::vector<std::pair<_Tp, std::size_t>> __ret;
    if (__x < 2) return __ret;

    for (_Tp __i = 2; __i * __i <= __x; ++__i)
    {
        std::size_t __count = 0;

        while (__x % __i == 0)
        {
            ++__count;
            __x /= __i;
        }

        if (__count) __ret.push_back(std::pair(__i, __count));
    }

    if (__x) __ret.push_back(std::pair(__x, 1));
    return __ret;
}

template<typename _Tp, typename _Data = std::pair<_Tp, std::size_t>,
    typename _Cont = std::vector<_Data>>
std::string prime_factor_str(const _Cont& __res)
{
    std::ostringstream __oss;

    for (const _Data& __data : __res)
    {
        __oss << __data.first;
        if (__data.second > 1) __oss << '^' << __data.second;
        __oss << '*';
    }

    std::string __ret = __oss.str();
    __ret.pop_back();
    return std::move(__ret);
}

}

#endif
