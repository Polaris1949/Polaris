#ifndef _POLLIB_TYPE
#define _POLLIB_TYPE 1

#include <typeinfo>

namespace polaris
{

template<typename _Tp, typename... _Args>
_Tp __type_ctor(_Args&&... __args)
{
    return _Tp(__args...);
}

template<typename _Tp, typename... _Args>
void __type_ctor_wrap(_Tp& __x, _Args&&... __args)
{
    __x = _Tp(__args...);
}

class type
{
    enum _Op
    {_Op_info, _Op_construct};

    union _Arg
    {
        const std::type_info* _M_typeinfo;
        type* _M_type;
    };

    template<typename _Tp>
    struct _Ctor
    {
        static void _S_wrap(_Tp& __x, auto&&... __args)
        {
            __x = _S_ctor(__args...);
        }

        static _Tp _S_ctor(auto&&... __args)
        {
            return _Tp(__args...);
        }
    };

    template<typename _Tp>
    struct _Manager
    {
        void _S_manage(_Op __which, _Arg* __arg)
        {
            switch (__which)
            {
                case _Op_construct: break;
                default: break;
            }
        }

        template<typename... _Args>
        _Tp _S_construct(_Args&&... __args)
        {
            return _Tp(__args...);
        }
    };

    void (*_M_ctor)(...);
    char* _M_buffer;
    std::size_t _M_size;
//    auto (*_M_wrapper)(...);

public:
    type()
        : _M_ctor(nullptr), _M_buffer(), _M_size()
    {}

    template<typename _Tp>
    type(_Tp&& __arg)
        : _M_ctor(&__type_ctor_wrap<_Tp>), _M_buffer(), _M_size(sizeof(__arg))
    {_M_buffer = new char[_M_size];}

    template<typename... _Args>
    auto construct(_Args&&... __args)
    {
        _M_ctor(_M_buffer, __args...);
        return _M_buffer;
    }

    ~type() noexcept
    {delete _M_buffer;}
};

}

#endif
