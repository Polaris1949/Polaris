#ifndef _POLLIB_TYPE
#define _POLLIB_TYPE 1

#include <polaris/version>
#include <type_traits>
#include <utility>

namespace polaris
{

// A wrapper class for fundamental types.
template<typename _Tp, typename _Req =
    std::enable_if_t<std::is_fundamental_v<_Tp>>>
class fundamental_type
{
public:
    using value_type = _Tp;

private:
    _Tp _M_data;

public:
    fundamental_type() noexcept = default;
    fundamental_type(const value_type& __data) noexcept;
    fundamental_type(value_type&& __data) noexcept;
    ~fundamental_type() noexcept = default;

    value_type
    data() const;

    value_type*
    address() const;

    std::enable_if_t<is_plusable_v<value_type>, fundamental_type>&
    operator += (const fundamental_type& __rhs) noexcept;

    std::enable_if_t<is_minusable_v<value_type>, fundamental_type>&
    operator -= (const fundamental_type& __rhs) noexcept;

    std::enable_if_t<is_multiplyable_v<value_type>, fundamental_type>&
    operator *= (const fundamental_type& __rhs) noexcept;

    fundamental_type&
    operator /= (const fundamental_type& __rhs) noexcept;

    fundamental_type&
    operator %= (const fundamental_type& __rhs) noexcept;

    // ...
};

template<typename _Tp, typename _Req>
fundamental_type<_Tp, _Req>::
fundamental_type(const value_type& __data) noexcept
    : _M_data{__data}
{}

template<typename _Tp, typename _Req>
fundamental_type<_Tp, _Req>::
fundamental_type(value_type&& __data) noexcept
    : _M_data{std::move(__data)}
{}

template<typename _Tp, typename _Req>
_Tp
fundamental_type<_Tp, _Req>::
data() const
{ return this->_M_data; }

template<typename _Tp, typename _Req>
_Tp*
fundamental_type<_Tp, _Req>::
address() const
{ return &this->_M_data; }

template<typename _Tp, typename _Req>
fundamental_type<_Tp, _Req>&
fundamental_type<_Tp, _Req>::
operator += (const fundamental_type& __rhs) noexcept
{ this->_M_data += __rhs._M_data; return *this; }

}

#endif /* _POLLIB_TYPE */
