// Library concepts -*- C++ -*-

// Copyright (C) 1997-2017 Free Software Foundation, Inc.
//
// This file is part of the Polaris C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file     concepts
 *  @brief    Concepts library
 *  @author   Polaris Zhao
 *  @version  3.0
 *  @note     Your compiler must support C++20 or Concepts TS.
 *  @todo     This library is incompelete.
 *
 *  This is a Polaris C++ Library header.
**/

#ifndef _POLLIB_CONCEPTS
#define _POLLIB_CONCEPTS 1

#pragma GCC system_header

#include <polaris/version>
#include <functional>
#include <utility>
#include <polaris/type_traits>

#if __cpp_concepts
#if __cplusplus >= 202000L
// C++20 available support
#else
#define concept concept bool
// Concepts TS available support
#endif /* C++20 */
#else
#error no available support for this library
#endif /* !__cpp_concepts */

namespace polaris
{

namespace __cc_detail
{

template<typename _Tp, typename _Up,
	template<typename> typename _TpQual,
	template<typename> typename _UpQual>
struct basic_common_reference {};

template<typename _Tp>
struct __type_qual_impl_const
{
	template<typename _Up>
	using type = std::conditional_t<std::is_const_v<_Tp>,
		std::add_const_t<_Up>, _Up>;
};

template<typename _Tp>
struct __type_qual_impl_volatile
{
	template<typename _Up>
	using type = std::conditional_t<std::is_volatile_v<_Tp>,
		std::add_volatile_t<_Up>, _Up>;
};

template<typename _Tp>
struct __type_qual_impl_cv
{
	template<typename _Up>
	using __type_0 = typename __type_qual_impl_const<_Tp>::
		template type<_Up>;

	template<typename _Up>
	using type = typename __type_qual_impl_volatile<_Tp>::
		template type<__type_0<_Up>>;
};

template<typename _Tp>
struct __type_qual_impl_lvref
{
	template<typename _Up>
	using type = std::conditional_t<std::is_lvalue_reference_v<_Tp>,
		std::add_lvalue_reference_t<_Up>, _Up>;
};

template<typename _Tp>
struct __type_qual_impl_rvref
{
	template<typename _Up>
	using type = std::conditional_t<std::is_rvalue_reference_v<_Tp>,
		std::add_rvalue_reference_t<_Up>, _Up>;
};

template<typename _Tp>
struct __type_qual_impl_ref
{
	template<typename _Up>
	using __type_0 = typename __type_qual_impl_lvref<_Tp>::
		template type<_Up>;

	template<typename _Up>
	using type = typename __type_qual_impl_rvref<_Tp>::
		template type<__type_0<_Up>>;
};

template<typename _Tp>
struct __type_qual_impl_cvref
{
	template<typename _Up>
	using __type_0 = typename __type_qual_impl_cv<_Tp>::
		template type<_Up>;

	template<typename _Up>
	using type = typename __type_qual_impl_ref<_Tp>::
		template type<__type_0<_Up>>;
};

template<typename _Tp>
struct __type_qual
{
	template<typename _Up>
	using type = typename __type_qual_impl_cvref<_Tp>::
		template type<_Up>;
};

struct __basic_comref_check_impl
{
	template<typename _Tp, typename _Up, typename _Cz = typename
		std::basic_common_reference<std::remove_cvref_t<_Tp>,
		std::remove_cvref_t<_Up>, template __type_qual<_Tp>::type,
		template __type_qual<_Up>::type>::type>
	static std::true_type _S_test(int);

	template<typename, typename>
	static std::false_type _S_test(...);
};

template<typename _Tp, typename _Up>
struct __basic_comref_check_base
	: public __basic_comref_check_impl
{
	using type = decltype(_S_test<_Tp, _Up>(0));
};

template<typename _Tp, typename _Up>
struct __basic_comref_check
	: public typename __basic_comref_check_base<_Tp, _Up>::type
{};

template<typename _Tp, typename _Up>
struct __basic_comref
{
	template<typename _Tp, typename _Up>
	using type = typename
		std::basic_common_reference<std::remove_cvref_t<_Tp>,
		std::remove_cvref_t<_Up>, template __type_qual<_Tp>::type,
		template __type_qual<_Up>::type>::type;
};

template<typename _Tp, typename _Up>
inline constexpr bool __basic_comref_check_v =
	__basic_comref_check<_Tp, _Up>::value;

template<typename _Tp, typename _Up>
struct __simple_comref_1_check
	: public std::conjunction_t<std::is_lvalue_reference_t<_Tp>,
		std::is_rvalue_reference_t<_Up>>
{
};

template<typename _Tp, typename _Up>
struct __simple_comref_1
{
	// TODO
};

template<typename _Tp, typename _Up>
struct __simple_comref;

template<typename _Tp, typename _Up>
using __simple_comref_t = typename __simple_comref<_Tp, _Up>::type;

template<typename _Tp...>
struct common_reference;

template<typename _Tp...>
using common_reference_t = typename common_reference<_Tp...>::type;

struct common_reference<> {};

template<typename _Tp>
struct common_reference<_Tp>
{
	using type = _Tp;
};

template<typename _Tp, typename _Up>
struct __comref_impl_1_check
	: public std::conjunction_t<std::is_reference<_Tp>, std::is_reference<_Up>
{};

template<typename _Tp, typename _Up>
struct __comref_impl_1
{
	using type = __simple_comref_t<_Tp, _Up>; // TODO
};

template<typename _Tp, typename _Up>
struct __comref_impl_2_check
	: public typename __basic_comref_check<_Tp, _Up>::type
{};

template<typename _Tp, typename _Up>
struct __comref_impl_2
{
	using type = typename __basic_comref<_Tp, _Up>::type;
};

struct __comref_impl_3_check_impl
{
	template<typename _Tp>
	static _Tp _S_val();

	template<typename _Tp, typename _Up, typename _Req =
		decltype(true ? _S_val<_Tp> : _S_val<_Up>)>
	static std::true_type _S_test(int);

	template<typename, typename>
	static std::false_type _S_test(...);
};

template<typename _Tp, typename _Up>
struct __comref_impl_3_check_base
	: public __comref_impl_3_check_impl
{
	using type = decltype(_S_test<_Tp, _Up>(0));
};

template<typename _Tp, typename _Up>
struct __comref_impl_3_check
	: public typename __comref_impl_3_check_base<_Tp, _Up>::type
{};

struct __comref_impl_3_impl
{
	template<typename _Tp>
	static _Tp _S_val();

	using type = decltype(true ? _S_val<_Tp> : _S_val<_Up>);
};

template<typename _Tp, typename _Up>
struct __comref_impl_3
{
	using type = typename __comref_impl_3_impl<_Tp, _Up>::type;
};

struct __comref_impl_4_check_impl
{
	template<typename _Tp, typename _Up, typename _Req =
		std::common_type_t<_Tp, _Up>>
	static std::true_type _S_test(int);

	template<typename, typename>
	static std::false_type _S_test(...);
};

template<typename _Tp, typename _Up>
struct __comref_impl_4_check_base
	: public __comref_impl_4_check_impl
{
	using type = decltype(_S_test<_Tp, _Up>(0));
};

template<typename _Tp, typename _Up>
struct __comref_impl_4_check
	: public typename __comref_impl_4_check_base<_Tp, _Up>::type
{};

template<typename _Tp, typename _Up>
struct __comref_impl_4
{
	using type = std::common_type_t<_Tp, _Up>;
};

template<typename _Tp, typename _Up>
struct common_reference<_Tp, _Up>
{
	using type = void; // TODO
};

template<typename _Tp, typename _Up, typename _Rest...>
struct common_reference<_Tp, _Up, _Rest...>
	: public common_reference_t<common_reference_t<_Tp, _Up>, _Rest...>
{};

#if POL_DEBUG
template<typename _Tp, typename _Up>
concept same = std::is_same_v<_Tp, _Up> && std::is_same_v<_Up, _Tp>;
#else
template<typename _Tp, typename _Up>
concept same = std::is_same_v<_Tp, _Up>;
#endif

}

template<typename _Tp, typename _Up>
concept cc_same = __cc_detail::same<_Tp, _Up>;

template<typename _Derived, typename _Base>
concept cc_derived_from = std::is_base_of_v<_Base, _Derived> &&
	std::is_convertible_v<const volatile _Derived*, const volatile _Base*>;

template<typename _From, typename _To>
concept cc_convertible_to = std::is_convertible_v<_From, _To> &&
	requires(_From (&__f)()) { static_cast<_To>(__f()); };

#if __cplusplus >= 202000L
template<typename _Tp, typename _Up>
concept cc_common_reference = cc_same<std::common_reference_t<_Tp, _Up>,
	std::common_reference_t<_Up, _Tp>> &&
	cc_convertible_to<_Tp, std::common_reference_t<_Tp, _Up>> &&
	cc_convertible_to<_Up, std::common_reference_t<_Tp, _Up>>;

template<typename _Tp, typename _Up>
concept cc_common = cc_same<std::common_type_t<_Tp, _Up>,
		std::common_type_t<_Up, _Tp>> &&
	cc_convertible_to<_Tp, std::common_type_t<_Tp, _Up>> &&
	cc_convertible_to<_Up, std::common_type_t<_Tp, _Up>> &&
	cc_common_reference<
		std::add_lvalue_reference_t<const _Tp>,
		std::add_lvalue_reference_t<const _Up>> &&
	cc_common_reference<
		std::add_lvalue_reference_t<std::common_type_t<_Tp, _Up>>,
		std::common_reference_t<
		std::add_lvalue_reference_t<const _Tp>,
		std::add_lvalue_reference_t<const _Up>>>;
#else
#warning concept cc_common_reference unsupported; satisfied anywhere
template<typename _Tp, typename _Up>
concept cc_common_reference = true_v<_Tp, _Up>;

#warning concept cc_common unsupported; satisfied anywhere
template<typename _Tp, typename _Up>
concept cc_common = true_v<_Tp, _Up>;
#endif /* C++20 */

template<typename _Tp>
concept cc_integral = std::is_integral_v<_Tp>;

template<typename _Tp>
concept cc_signed_integral = cc_integral<_Tp> && std::is_signed_v<_Tp>;

template<typename _Tp>
concept cc_unsigned_integral = cc_integral<_Tp> && !cc_signed_integral<_Tp>;

template<typename _LHS, typename _RHS>
concept cc_assignable = std::is_lvalue_reference_v<_LHS> &&
	cc_common_reference<const std::remove_reference_t<_LHS>&,
		const std::remove_reference_t<_RHS>&> &&
	requires(_LHS __lhs, _RHS&& __rhs)
	{
		__lhs = std::forward<_RHS>(__rhs);
		requires cc_same<decltype(__lhs = std::forward<_RHS>(__rhs)), _LHS>;
	};

template<typename _Tp>
concept cc_swappable = std::is_swappable_v<_Tp>;

template<typename _Tp, typename _Up>
concept cc_swappable_with = std::is_swappable_with_v<_Tp, _Tp> &&
	std::is_swappable_with_v<_Up, _Up> &&
	cc_common_reference<const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&> &&
	std::is_swappable_with_v<_Tp, _Up> &&
	std::is_swappable_with_v<_Up, _Tp>;

template<typename _Tp>
concept cc_destructible = std::is_nothrow_destructible_v<_Tp>;

template<typename _Tp, typename... _Args>
concept cc_constructible = cc_destructible<_Tp> &&
	std::is_constructible_v<_Tp, _Args...>;

template<typename _Tp>
concept cc_default_constructible = cc_constructible<_Tp>;

template<typename _Tp>
concept cc_move_constructible = cc_constructible<_Tp, _Tp>
	&& cc_convertible_to<_Tp, _Tp>;

template<typename _Tp>
concept cc_copy_constructible = cc_move_constructible<_Tp> &&
	cc_constructible<_Tp, _Tp&> && cc_convertible_to<_Tp&, _Tp> &&
	cc_constructible<_Tp, const _Tp&> && cc_convertible_to<const _Tp&, _Tp> &&
	cc_constructible<_Tp, const _Tp> && cc_convertible_to<const _Tp, _Tp>;

template<typename _Tp>
concept cc_movable = std::is_object_v<_Tp> && cc_move_constructible<_Tp> &&
	cc_assignable<_Tp&, _Tp> && cc_swappable<_Tp>;

#if __cplusplus >= 202000L
template<typename _Bp>
concept cc_boolean = cc_movable<std::remove_cvref_t<_Bp>> &&
	requires(const std::remove_reference_t<_Bp>& __b1,
		const std::remove_reference_t<_Bp>& __b2, const bool __a)
	{
		requires cc_convertible_to<const std::remove_reference_t<_Bp>&, bool>;
		!__b1;        requires cc_convertible_to<decltype(!__b1), bool>;
		__b1 && __a;  requires cc_same<decltype(__b1 && __a), bool>;
		__b1 || __a;  requires cc_same<decltype(__b1 || __a), bool>;
		__b1 && __b2; requires cc_same<decltype(__b1 && __b2), bool>;
		__a && __b2;  requires cc_same<decltype(__a && __b2), bool>;
		__b1 || __b2; requires cc_same<decltype(__b1 || __b2), bool>;
		__a || __b2;  requires cc_same<decltype(__a || __b2), bool>;
		__b1 == __b2; requires cc_convertible_to<decltype(__b1 == __b2), bool>;
		__b1 == __a;  requires cc_convertible_to<decltype(__b1 == __a), bool>;
		__a == __b2;  requires cc_convertible_to<decltype(__a == __b2), bool>;
		__b1 != __b2; requires cc_convertible_to<decltype(__b1 != __b2), bool>;
		__b1 != __a;  requires cc_convertible_to<decltype(__b1 != __a), bool>;
		__a != __b2;  requires cc_convertible_to<decltype(__a != __b2), bool>;
	};
#else
#warning concept cc_boolean unsupported; satisfied anywhere
template<typename _Bp>
concept cc_boolean = true_v<_Bp>;
#endif /* C++2O */

template<typename _Tp, typename _Up>
concept cc_weakly_equality_comparable_with =
	requires(const std::remove_reference_t<_Tp>& __t,
		const std::remove_reference_t<_Up>& __u)
	{
		__t == __u; requires cc_boolean<decltype(__t == __u)>;
		__t != __u; requires cc_boolean<decltype(__t != __u)>;
		__u == __t; requires cc_boolean<decltype(__u == __t)>;
		__u != __t; requires cc_boolean<decltype(__u != __t)>;
	};

template<typename _Tp>
concept cc_equality_comparable = cc_weakly_equality_comparable_with<_Tp, _Tp>;

template<typename _Tp, typename _Up>
concept cc_equality_comparable_with = cc_equality_comparable<_Tp> &&
	cc_equality_comparable<_Up> &&
	cc_common_reference<const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&> &&
	cc_equality_comparable<std::common_reference_t<
		const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&>> &&
	cc_weakly_equality_comparable_with<_Tp, _Up>;

template<typename _Tp>
concept cc_strict_totally_ordered = cc_equality_comparable<_Tp> &&
	requires(const std::remove_reference_t<_Tp>& __a,
		const std::remove_reference_t<_Tp>& __b)
	{
		__a < __b;  requires cc_boolean<decltype(__a < __b)>;
		__a > __b;  requires cc_boolean<decltype(__a > __b)>;
		__a <= __b; requires cc_boolean<decltype(__a <= __b)>;
		__a >= __b; requires cc_boolean<decltype(__a >= __b)>;
	};

template<typename _Tp, typename _Up>
concept cc_strict_totally_ordered_with =
	cc_strict_totally_ordered<_Tp> &&
	cc_strict_totally_ordered<_Up> &&
	cc_common_reference<const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&> &&
	cc_strict_totally_ordered<std::common_reference_t<
		const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&>> &&
	cc_equality_comparable_with<_Tp, _Up> &&
	requires(const std::remove_reference_t<_Tp>& __t,
		const std::remove_reference_t<_Up>& __u)
	{
		__t < __u;  requires Boolean<decltype(__t < __u)>;
		__t > __u;  requires Boolean<decltype(__t > __u)>;
		__t <= __u; requires Boolean<decltype(__t <= __u)>;
		__t >= __u; requires Boolean<decltype(__t >= __u)>;
		__u < __t;  requires Boolean<decltype(__u < __t)>;
		__u > __t;  requires Boolean<decltype(__u > __t)>;
		__u <= __t; requires Boolean<decltype(__u <= __t)>;
		__u >= __t; requires Boolean<decltype(__u >= __t)>;
	};

/* @FIXME
template<typename _Tp>
concept Movable = std::is_object_v<_Tp> && MoveConstructible<_Tp> &&
	Assignable<_Tp&, _Tp> && Swappable<_Tp>;
*/

template<typename _Tp>
concept cc_copyable = cc_copy_constructible<_Tp> && cc_movable<_Tp> &&
	cc_assignable<_Tp&, const _Tp&>;

template<typename _Tp>
concept cc_semiregular = cc_copyable<_Tp> && cc_default_constructible<_Tp>;

template<typename _Tp>
concept cc_regular = cc_semiregular<_Tp> && cc_equality_comparable<_Tp>;

template<typename _Fp, typename... _Args>
concept cc_invocable =
	requires(_Fp&& __f, _Args&&... __args)
	{
		std::invoke(std::forward<_Fp>(__f), std::forward<_Args>(__args)...);
		/* not required to be equality preserving */
	};

template<typename _Fp, typename... _Args>
concept cc_regular_invocable = cc_invocable<_Fp, _Args...>;

template<typename _Fp, typename... _Args>
concept cc_predicate = cc_regular_invocable<_Fp, _Args...> &&
	cc_boolean<std::invoke_result_t<_Fp, _Args...>>;

template<typename _Rp, typename _Tp, typename _Up>
concept cc_relation = cc_predicate<_Rp, _Tp, _Tp>
	&& cc_predicate<_Rp, _Up, _Up>
	&& cc_common_reference<const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&>
	&& cc_predicate<_Rp, std::common_reference_t<
		const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&>,
		std::common_reference_t<const std::remove_reference_t<_Tp>&,
		const std::remove_reference_t<_Up>&>>
	&& cc_predicate<_Rp, _Tp, _Up> && cc_predicate<_Rp, _Up, _Tp>;

template<typename _Rp, typename _Tp, typename _Up>
concept cc_strict_weak_order = cc_relation<_Rp, _Tp, _Up>;

} // namespace polaris

#if __cpp_concepts && __cplusplus < 202000L
#undef concept
#endif /* Concepts TS */

#endif /* _POLLIB_CONCEPTS */
