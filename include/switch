// Switch case components -*- C++ -*-

// Copyright (C) 1997-2017 Free Software Foundation, Inc.
//
// This file is part of the Polaris C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file     switch
 *  @brief    Switch case components
 *  @author   Polaris Zhao
 *  @version  3.0
 *
 *  This is a Polaris C++ Library header.
**/

#ifndef _POLLIB_SWITCH
#define _POLLIB_SWITCH 1

#pragma GCC system_header

#include <polaris/version>
#include <tuple>
#include <utility>

#if __cpp_return_type_deduction < 201304L
#error return type deduction required in this library
#else

namespace polaris
{

// switch_case: primary template.
template<typename _Tp, typename _Up, typename... _Vp>
auto
switch_case(_Tp&&, _Up&&, _Vp&&...);

// __switch_impl: default case. (0)
template<typename _Tp, typename _Up>
auto
__switch_impl(_Tp&&, _Up&&);

// __switch_impl: specific case described below. (1)
// if case value equals to switch value, invoke function.
template<typename _Tp, typename _Up, typename... _Vp,
	typename _Ap, typename _Bp>
auto
__switch_impl(_Tp&&, _Up&&, std::pair<_Ap, _Bp>&&, _Vp&&...);

// __switch_impl: specific case described below. (2)
// if one of case values equals to switch value, invoke function.
template<typename _Tp, typename _Up, typename... _Vp,
	typename... _Ap, typename _Bp>
auto
__switch_impl(_Tp&&, _Up&&, std::pair<std::tuple<_Ap...>, _Bp>&&, _Vp&&...);

// __switch_impl: specific case described below. (3)
// if _Cp yielded switch value equals to case value, invoke function.
template<typename _Tp, typename _Up, typename... _Vp,
	typename _Ap, typename _Bp, typename _Cp>
auto
__switch_impl(_Tp&&, _Up&&, std::tuple<_Ap, _Bp, _Cp>&&, _Vp&&...);

// __switch_impl: specific case described below. (4)
// if _Cp yielded switch value equals to one of case values, invoke function.
template<typename _Tp, typename _Up, typename... _Vp,
	typename... _Ap, typename _Bp, typename _Cp>
auto
__switch_impl(_Tp&&, _Up&&, std::tuple<std::tuple<_Ap...>, _Bp, _Cp>&&,
	_Vp&&...);

// __one_of: check whether the value is in the tuple
template<typename _Tp, typename... _Up>
bool
__one_of(_Tp&&, std::tuple<_Up...>&&);

// __one_of_impl: in range (0)
template<std::size_t __i, typename _Tp, typename... _Up,
	typename = std::enable_if_t<(__i < sizeof...(_Up))>>
bool
__one_of_impl(_Tp&&, std::tuple<_Up...>&&);

// __one_of_impl: out of range (1)
template<std::size_t __i, typename _Tp, typename... _Up,
	typename = std::enable_if_t<(__i >= sizeof...(_Up))>,
	typename = void>
bool
__one_of_impl(_Tp&&, std::tuple<_Up...>&&);

// switch_case
template<typename _Tp, typename _Up, typename... _Vp>
auto
switch_case(_Tp&& __switch, _Up&& __default, _Vp&&... __case)
{
	return __switch_impl(std::forward<_Tp&&>(__switch),
		std::forward<_Up&&>(__default), std::forward<_Vp&&>(__case)...);
}

// __switch_impl (0)
template<typename _Tp, typename _Up>
auto
__switch_impl(_Tp&& __switch, _Up&& __default)
{
	return __default();
}

// __switch_impl (1)
template<typename _Tp, typename _Up, typename... _Vp,
	typename _Ap, typename _Bp>
auto
__switch_impl(_Tp&& __switch, _Up&& __default,
	std::pair<_Ap, _Bp>&& __cur, _Vp&&... __case)
{
	if (__switch == __cur.first)
		return __cur.second();
	else
		return __switch_impl(std::forward<_Tp&&>(__switch),
			std::forward<_Up&&>(__default), std::forward<_Vp&&>(__case)...);
}

// __switch_impl (2)
template<typename _Tp, typename _Up, typename... _Vp,
	typename... _Ap, typename _Bp>
auto
__switch_impl(_Tp&& __switch, _Up&& __default,
	std::pair<std::tuple<_Ap...>, _Bp>&& __cur, _Vp&&... __case)
{
	if (__one_of(std::forward<_Tp&&>(__switch),
			std::forward<std::tuple<_Ap...>&&>(__cur.first)))
		return __cur.second();
	else
		return __switch_impl(std::forward<_Tp&&>(__switch),
			std::forward<_Up&&>(__default), std::forward<_Vp&&>(__case)...);
}

// __switch_impl (3)
template<typename _Tp, typename _Up, typename... _Vp,
	typename _Ap, typename _Bp, typename _Cp>
auto
__switch_impl(_Tp&& __switch, _Up&& __default,
	std::tuple<_Ap, _Bp, _Cp>&& __cur, _Vp&&... __case)
{
	if (std::get<2>(__cur)(__switch) == std::get<0>(__cur))
		return std::get<1>(__cur)();
	else
		return __switch_impl(std::forward<_Tp&&>(__switch),
			std::forward<_Up&&>(__default), std::forward<_Vp&&>(__case)...);
}

// __switch_impl (4)
template<typename _Tp, typename _Up, typename... _Vp,
	typename... _Ap, typename _Bp, typename _Cp>
auto
__switch_impl(_Tp&& __switch, _Up&& __default,
	std::tuple<std::tuple<_Ap...>, _Bp, _Cp>&& __cur, _Vp&&... __case)
{
	if (__one_of(std::forward<_Cp&&>(std::get<2>(__cur)(__switch)),
			std::forward<std::tuple<_Ap...>&&>(std::get<0>(__cur))))
		return std::get<1>(__cur)();
	else
		return __switch_impl(std::forward<_Tp&&>(__switch),
			std::forward<_Up&&>(__default), std::forward<_Vp&&>(__case)...);
}

// __one_of
template<typename _Tp, typename... _Up>
bool
__one_of(_Tp&& __switch, std::tuple<_Up...>&& __cur)
{
	return __one_of_impl<0>(std::forward<_Tp&&>(__switch),
		std::forward<std::tuple<_Up...>&&>(__cur));
}

// __one_of_impl (0)
template<std::size_t __i, typename _Tp, typename... _Up,
	typename = std::enable_if_t<(__i < sizeof...(_Up))>>
bool
__one_of_impl(_Tp&& __switch, std::tuple<_Up...>&& __cur)
{
	if (__switch == std::get<__i>(__cur))
		return true;
	else
		return __one_of_impl<__i + 1>(std::forward<_Tp&&>(__switch),
			std::forward<std::tuple<_Up...>&&>(__cur));
}

// __one_of_impl (1)
template<std::size_t __i, typename _Tp, typename... _Up,
	typename = std::enable_if_t<(__i >= sizeof...(_Up))>,
	typename = void>
bool
__one_of_impl(_Tp&& __switch, std::tuple<_Up...>&& __cur)
{
	return false;
}

}

#endif /* __cpp_return_type_deduction */

#endif /* _POLLIB_SWITCH */
